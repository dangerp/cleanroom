{"name":"Cleanroom","tagline":"(More) safely evaluate Ruby DSLs with cleanroom","body":"Ruby Cleanroom\r\n==============\r\n[![Gem Version](http://img.shields.io/gem/v/cleanroom.svg)][gem]\r\n[![Build Status](http://img.shields.io/travis/sethvargo/cleanroom.svg)][travis]\r\n[![Code Climate](http://img.shields.io/codeclimate/github/sethvargo/cleanroom.svg)][codeclimate]\r\n[![Gittip](http://img.shields.io/gittip/sethvargo.svg)][gittip]\r\n\r\n[gem]: https://rubygems.org/gems/cleanroom\r\n[travis]: http://travis-ci.org/sethvargo/cleanroom\r\n[codeclimate]: https://codeclimate.com/github/sethvargo/cleanroom\r\n[gittip]: https://www.gittip.com/sethvargo\r\n\r\nRuby is an excellent programming language for creating and managing custom DSLs, but how can you securely evaluate a DSL while explicitly controlling the methods exposed to the user? Our good friends `instance_eval` and `instance_exec` are great, but they expose all methods - public, protected, and private - to the user. Even worse, they expose the ability to accidentally or intentionally alter the behavior of the system! The cleanroom pattern is a safer, more convenient, Ruby-like approach for limiting the information exposed by a DSL while giving users the ability to write awesome code!\r\n\r\nThe cleanroom pattern is a unique way for more safely evaluating Ruby DSLs without adding additional overhead.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'cleanroom'\r\n```\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install cleanroom\r\n\r\n\r\nUsage\r\n-----\r\n\r\n### Setup\r\nIn order to use the cleanroom, you must first load the cleanroom gem:\r\n\r\n```ruby\r\nrequire 'cleanroom'\r\n```\r\n\r\nNext, for any file you wish to be evaluated as a DSL, include the module:\r\n\r\n```ruby\r\nclass MyDSL\r\n  include Cleanroom\r\nend\r\n```\r\n\r\n### Writing DSLs\r\nFor each public method you with to expose as a DSL method, call `expose` after the method definition in your class:\r\n\r\n```ruby\r\nclass MyDSL\r\n  include Cleanroom\r\n\r\n  def my_method\r\n    # ...\r\n  end\r\n  expose :my_method\r\n\r\n  def public_method\r\n    # ...\r\n  end\r\n\r\n  private\r\n\r\n  def private_method\r\n    # ...\r\n  end\r\nend\r\n```\r\n\r\nIn this example, `MyDSL` exposes two public API methods:\r\n\r\n- `my_method`\r\n- `public_method`\r\n\r\nwhich would be accessible via:\r\n\r\n```ruby\r\ninstance = MyDSL.new\r\ninstance.my_method\r\ninstance.public_method\r\n```\r\n\r\nMyDSL also exposes one DSL method:\r\n\r\n- `my_method`\r\n\r\nwhich would be accessible in a DSL file:\r\n\r\n```ruby\r\nmy_method\r\n```\r\n\r\nThe use of the `expose` method has the added advantage of clearly identifying which methods are available as part of the DSL.\r\n\r\nThe method `private_method` is never accessible in the DSL or as part of the public API.\r\n\r\n### Evaluating DSLs\r\nThe cleanroom also includes the ability to more safely evaluate DSL files. Given an instance of a class, you can call `evaluate` or `evaluate_file` to read a DSL.\r\n\r\n```ruby\r\ninstance = MyDSL.new\r\n\r\n# Using a Ruby block\r\ninstance.evaluate do\r\n  my_method\r\nend\r\n\r\n# Using a String\r\ninstance.evaluate \"my_method\"\r\n\r\n# Given a file at /file\r\ninstance.evaluate_file('/file')\r\n```\r\n\r\nThese same methods are available on the class as well, but require you pass in the instance:\r\n\r\n```ruby\r\ninstance = MyDSL.new\r\n\r\n# Using a Ruby block\r\nMyDSL.evaluate(instance) do\r\n  my_method\r\nend\r\n\r\n# Using a String\r\nMyDSL.evaluate(instance) \"my_method\"\r\n\r\n# Given a file at /file\r\nMyDSL.evaluate_file(instance, '/file')\r\n```\r\n\r\nFor both of these examples, _the given instance is modified_, meaning `instance` holds the values after the evaluation took place.\r\n\r\n\r\n\"Security\"\r\n----------\r\nThe cleanroom gem tries to prevent unauthorized variable access and attempts to alter the behavior of the system.\r\n\r\nFirst, the underlying instance object is never stored in an instance variable. Due to the nature of `instance_eval`, it would be trivial for a malicious user to directly access methods on the delegate class.\r\n\r\n```ruby\r\n# Some DSL file\r\n@instance #=> nil\r\n```\r\n\r\nSecond, access to the underlying `instance` in the cleanroom is restricted to `self` by inspecting the `caller` attempts to access `__instance__` from outside of a method in the cleanroom will result in an error.\r\n\r\n```ruby\r\n# Some DSL file\r\n__instance__ #=> Cleanroom::InaccessibleError\r\nsend(:__instance__) #=> Cleanroom::InaccessibleError\r\n```\r\n\r\nThird, the ability to create new methods on the cleanroom is also disabled:\r\n\r\n```ruby\r\n# Some DSL file\r\nself.class.class_eval { } #=> Cleanroom::InaccessibleError\r\nself.class.instance_eval { } #=> Cleanroom::InaccessibleError\r\n```\r\n\r\nFourth, when delegating to the underlying instance object, `public_send` (as opposed to `send` or `__send__`) is used. Even if an attacker could somehow bypass the previous safeguards, they would be unable to call non-public methods on the delegate object.\r\n\r\nIf you find a security hole in the cleanroom implementation, please email me at the contact info found in my [GitHub profile](https://github.com/sethvargo). **Do not open an issue!**\r\n\r\n\r\nTesting\r\n-------\r\nIf you are using cleanroom in your DSLs, you will likely want to test a particular DSL method is exposed. Cleanroom packages some RSpec matchers for your convienence:\r\n\r\n```ruby\r\n# spec/spec_helper.rb\r\nrequire 'rspec'\r\nrequire 'cleanroom/rspec'\r\n```\r\n\r\nThis will define the following matchers:\r\n\r\n```ruby\r\n# Check against an instance\r\nexpect(:my_method).to be_an_exposed_method_on(instance)\r\n\r\n# Check against a class\r\nexpect(:my_method).to be_an_exposed_method_on(klass)\r\n\r\n# Check against an instance\r\nexpect(instance).to have_exposed_method(:my_method)\r\n\r\n# Check against a class\r\nexpect(klass).to have_exposed_method(:my_method)\r\n```\r\n\r\n\r\nContributing\r\n------------\r\n1. Fork the project\r\n1. Write tests\r\n1. Run tests\r\n1. Create a new Pull Request\r\n\r\n\r\nLicense\r\n-------\r\n```text\r\nCopyright 2014 Seth Vargo <sethvargo@gmail.com>\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}